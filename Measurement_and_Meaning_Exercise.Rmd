---
title: "Measurement_and_Meaning_Exercise"
author: "Liam Kniberg"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction?

# Exercises
Use non-parametric bootstrapping to derive a 95% confidence interval for the CV of a variable.
*Start by writing a function that computes the CV for a variable (see the Appendix for a brief introduction to writing functions in R). Then, simulate a random variable and write a loop that samples many times from this variable and computes the CV. *
```{r}
set.seed(12)
x <- rnorm(100, mean = 10, sd = 2)
mean(x)
sd(x)
```

```{r}
CV_function <- function(boot_mean, boot_sd) {
  cv <- boot_sd/boot_mean
  quantile_cv <- quantile(cv, c(0.025, 0.975))
  return (quantile_cv)
}

out_cv = NULL
sd_cv = NULL
for(i in 1:1000){
sample <- sample(x, replace=TRUE)
out_cv[i] <- mean(sample)
sd_cv[i] <- sd(sample)
  }

```

```{r}
CV_function(out_cv, sd_cv)
```

# Optional Exercise
Use simulated data to show the close relationship between the SD of log-transformed data and the CV on arithmetic scale. You may need e.g. the rnorm function and a for-loop to achieve this. One strategy would be to start with comparing the two values for a single case, then build a matrix to hold the paired values, and finally use a for-loop to populate the matrix. See Appendix 1 for help to get started with programming.
The following figure illustrates the kind of pattern we expect.

```{r}
h <- rnorm(100, mean = 10, sd = 2)

out_cv = NULL
sd_cv = NULL
log_sd_cv = NULL
for(i in 1:1000){
sample <- sample(h, replace=TRUE)
out_cv[i] <- mean(sample)
sd_cv[i] <- sd(sample)
log_sd_cv[i] <- sd(log(sample))

}

sd_h <- log_sd_cv
cv_h <- sd_cv/out_cv

plot(cv_h, sd_h)
abline(0, 1)

```

